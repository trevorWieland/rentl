# Agent OS Standards Index

architecture:
  adapter-interface-protocol:
    description: Never access infrastructure adapters directly; access protocols defined in the Core Domain
  api-response-format:
    description: All responses use pydantic-based {data, error, meta} envelopes
  config-path-resolution:
    description: Config paths resolve relative to config file parent, not CWD; keep configs in-workspace
  id-formats:
    description: UUIDv7 vs human-readable ID formats
  log-line-format:
    description: All log lines use stable JSONL pydantic-based schema with {timestamp, level, event, run_id, phase, message, data} fields
  naming-conventions:
    description: Use consistent naming conventions across all code; snake_case for modules/functions/variables, PascalCase for classes/types
  none-vs-empty:
    description: Meaning of None vs empty lists in schemas
  openrouter-provider-routing:
    description: Validate OpenRouter provider compatibility before pipeline runs; use provider-qualified model IDs and whitelists
  thin-adapter-pattern:
    description: Surface layers (CLI, TUI, API) are thin adapters; all business logic lives in the Core Domain

global:
  address-deprecations-immediately:
    description: Deprecation warnings must be addressed immediately; never defer to future work
  agent-tool-registration:
    description: Register tools with explicit names via pydantic_ai.Tool to prevent prompt/tool mismatches
  batch-alignment-feedback:
    description: Batch agents must verify output IDs match input IDs; provide structured retry feedback on mismatch
  no-placeholder-artifacts:
    description: Never commit placeholder values; all artifacts must be functional and verified at commit time
  prefer-dependency-updates:
    description: Prefer frequent dependency updates; use compatible ranges instead of exact pins
  pydantic-ai-structured-output:
    description: All LLM calls must use pydantic-ai Agent with output_type; never hand-roll JSON parsing
  required-tool-gating:
    description: Gate output tools until required function tools are called; use exhaustive end_strategy

python:
  async-first-design:
    description: Design all APIs around async/await for parallel agent execution and efficient LLM network IO
  cli-help-docstring-gating:
    description: Use form-feed to hide internal docstring sections from Typer help output
  enum-field-runtime-types:
    description: Never call .value on enum fields from Pydantic models; use_enum_values=True stores primitives not enum instances
  llm-output-tolerance:
    description: LLM-output schemas use extra=ignore to tolerate extra fields; config schemas may be strict
  modern-python-314:
    description: Use Python 3.14 modern features; avoid legacy constructs and outdated patterns
  pydantic-only-schemas:
    description: Never use dataclasses or plain classes; all schemas must use Pydantic with Field and validators
  strict-typing-enforcement:
    description: Never use Any or object in types; all Pydantic fields use Field with description and built-in validators

testing:
  bdd-for-integration-quality:
    description: Integration and quality tests must use BDD-style (Given/When/Then)
  make-all-gate:
    description: "Gate tiers: make check (task), make ci (CI PR), make all (spec); agents run make all locally, CI runs make ci"
  mandatory-coverage:
    description: Coverage mandatory for all features; tests must exercise actual behavior
  mock-execution-boundary:
    description: Mock at the actual execution boundary per test tier; verify mocks are invoked
  no-mocks-for-quality-tests:
    description: Quality tests use real LLMs; integration tests mock LLMs
  no-test-skipping:
    description: Never skip tests within a tier; CI skips make quality only (paid API keys); all else runs with zero skips
  test-timing-rules:
    description: "Strict timing limits per tier: unit <250ms, integration <5s, quality <30s"
  three-tier-test-structure:
    description: "All tests in unit/integration/quality folders; unit <250ms, integration <5s, quality <30s"
  validate-generated-artifacts:
    description: Generated artifacts must validate against consuming component schemas, not just syntax

ux:
  copy-pasteable-examples:
    description: All command examples in docs must be executable without modification
  frictionless-by-default:
    description: Guided setup and safe defaults for effortless first runs
  progress-is-product:
    description: Status, phase completion, and QA visibility must be immediate and unambiguous
  speed-with-guardrails:
    description: Fast iterations without sacrificing determinism or quality; speed and quality aren't tradeoffs
  stale-reference-prevention:
    description: Cross-reference audits must verify against actual CLI output and config files
  trust-through-transparency:
    description: No silent stalls; every phase, error, and status must be visible and explainable
